{
    "collab_server" : "",
    "contents" : "list.of.packages <- c(\"digest\", \"httr\",\"jsonlite\")\nnew.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,\"Package\"])]\nif(length(new.packages)) install.packages(new.packages)\nrequire(digest)\nrequire(jsonlite)\nrequire(httr)\nBlockchain <- function ()\n{\n  bc = list (\n    chain = list(),\n    currentTransactions  = list(),\n    nodes = list()\n  )\n  #' Create a new Block in the Blockchain\n  #'\n  #' @param proof <int> The proof given by the Proof of Work algorithm\n  #' @param previousHash <str> Hash of previous Block\n  #' @return new block generated given the \\code{proof} and the \\code{previousHash}\n  #' @examples  \n  #' blockchain = Blockchain()\n  #' blockchain$nextBlock(previousHash=1, proof=100) # genesis block\n  bc$nextBlock = function (proof, previousHash=NULL){\n    previousHash <- ifelse (is.null(previousHash), bc$hashBlock(bc$chain[length(bc$chain)]), previousHash)\n    block = list('block' = list('index' = length (bc$chain) + 1, 'timestamp' = as.numeric(Sys.time()) , 'transactions' =  bc$currentTransactions, 'proof' = proof, 'previousHash' = previousHash))\n    bc$currentTransactions = NULL\n    bc$chain <- append(bc$chain, block)\n    return (block)\n  }\n  #' Returns the last block in the Blockchain\n  #'\n  #' @examples  \n  #' blockchain$lastBlock()\n  bc$lastBlock = function () {\n    bc$chain[length(bc$chain)]\n  }\n  #' Register a new transaction in the Blockchain\n  #'\n  #' @param sender <str> address of the sender\n  #' @param recipient <str> address of the recipient\n  #' @param amount <int> transaction amount\n  #' @return  <int> Index of the Block that will hold this transaction\n  bc$addTransaction = function (sender, recipient, amount) \n  {\n    txn <-  list('transaction'= list('sender'=sender,'recipient'=recipient,'amount'=amount))\n    bc$currentTransactions <- append(bc$currentTransactions, txn)\n    last.block <- bc$lastBlock()\n    return(last.block$block$index + 1)\n  }\n  #' Hash a block using SHA256\n  #'\n  #' @param block <block> \n  #' @return  <str> SHA256 hashed value for \\code(block)\n  #' @examples  \n  bc$hashBlock = function (block) {\n    require(digest)\n    digest(block,algo=\"sha256\")\n  }\n  \n  #' Find a number p' such that hash(pp') contains leading 4 zeroes, where p is the previous p'\n  #' p is the previous proof and p' is the new proof\n  #' @param last_proof <block> \n  #' @return  <str> SHA256 hashed value for \\code(block)\n  bc$proofOfWork <- function (last_proof)\n  {\n    proof <- 0\n    while (!bc$validProof(last_proof, proof))\n    {\n      proof <- proof + 1\n    }\n    return (proof)\n  }\n  \n  #' Find a number p' such that hash(pp') ends with two zeroes, where p is the previous p'\n  #' p is the previous proof and p' is the new proof\n  #' @param last_proof <int> previous proof \n  #' @param proof <int> proof\n  #' @return  <bool> TRUE if correct, FALSE if not\n  bc$validProof <- function (last_proof, proof) \n  {\n    guess = paste0(last_proof,proof)\n    guess_hash = digest(guess, algo = 'sha256')\n    return (gsub('.*(.{2}$)', '\\\\1',guess_hash) == \"00\")\n  }\n  #' Checks whether a given blockchain is valid\n  #'\n  #' @return  <bool> TRUE if the chain is valid, FALSE otherwise\n  bc$validChain <- function (chain)\n  {\n    lastBlock <- chain[0]\n    currentIndex <- 1\n    while (currentIndex < length(chain))\n    {\n      block = chain[currentIndex]\n      # checking for valid linking\n      if (block$block$previousHash != bc$hashBlock(lastBlock)) {\n        return(FALSE)\n      }\n      # checking for proof validity\n      if(!bc$validProof(lastBlock$block$proof, block$block$proof))\n      {\n        return (FALSE)\n      }\n      lastBlock <- block\n      currentIndex <- currentIndex +1\n    }\n    return(TRUE)\n  }\n  #' Add a new node to the list of existing nodes\n  #' \n  #' @param address <str> full URL of the node  \n  #' @examples  \n  #' blockchain = Blockchain()\n  #' blockchain$registerNode('http://192.168.0.5:5000')\n  bc$registerNode <- function(address)\n  {\n    parsed_url = address\n    bc$nodes<- append(bc$nodes, parsed_url)\n  }\n  #' Resolve conflicts by replacing the current chain by the longest chain in the network\n  #'\n  #' @return  <bool> TRUE if the chain was replaced, FALSE otherwise\n  bc$handleConflicts <- function()\n  {\n    neighbours <- bc$nodes \n    new_chain <- NULL\n    max_length = length(bc$chain)\n    for (i in 1:length(neighbours))\n    {\n      chain.node <- GET(paste0(neighbours[i],'/chain'))\n      node.chain.length <- jsonlite::fromJSON(chain.node)$length\n      node.chain.chain <- jsonlite::fromJSON(chain.node)$chain \n      if (node.chain.length > max_length)\n      {\n        new_chain = node.chain.chain\n        max_length<-node.chain.length\n      }\n    }\n    if (!is.null(new_chain))\n    {\n      bc$chain <- new_chain \n    }\n  }\n  # Adding bc to the environment\n  bc <- list2env(bc)\n  class(bc) <- \"BlockchainClass\"\n  return(bc)\n}\n\nlist.of.packages <- c(\"uuid\")\nnew.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,\"Package\"])]\nif(length(new.packages)) install.packages(new.packages)\n\nrequire(uuid)\n# make sure you put the path of your blockchain.R file\nsource('blockchain.R')\n\n# Generate a globally unique address for this node\nnode_identifier = gsub('-','',UUIDgenerate())\n# Instantiate the Blockchain\nblockchain = Blockchain()\n# genesis block\nblockchain$nextBlock(previousHash=1, proof=100)\n#* @serializer custom_json\n#* @post /transactions/new\nfunction(req)\n{\n  #eg req_json <- '{\"sender\": \"my address\", \"recipient\": \"someone else address\", \"amount\": 5}'\n  #values <- jsonlite::fromJSON(req_json)\n  values <- jsonlite::fromJSON(req$postBody)\n  \n  # Check that the required fields are in the POST'ed data\n  required = c('sender','recipient', 'amount')\n  if (!all(required %in% names(values))) {\n    return ('Missing Values - sender, recipient and amount are required')\n  }\n  index = blockchain$addTransaction(values$sender, values$recipient, values$amount)\n  \n  list('message' = paste('Transaction will be added to Block', index))\n}\n\n#* @serializer custom_json\n#* @get /chain\nfunction(req)\n{\n  list('chain'=blockchain$chain, 'length'=length(blockchain$chain))\n}\n#* @serializer custom_json\n#* @get /mine\nfunction(req)\n{\n  # We run the proof of work algorithm to get the next proof\n  lastBlock = blockchain$lastBlock()\n  lastProof = lastBlock$block$proof\n  proof = blockchain$proofOfWork(lastProof)\n  \n  # We must receive a reward for finding the proof.\n  # The sender is \"0\" to signify that this node has mined a new coin.\n  blockchain$addTransaction(sender=\"0\",recipient = node_identifier, amount=1)\n  \n  # Forge the new block by adding it to the chain\n  previousHash = blockchain$hashBlock(lastBlock)\n  block = blockchain$nextBlock(proof, previousHash)\n  list('message'='New block forged', 'index'= block$block$index, 'transactions'= block$block$transactions, 'proof'=block$block$proof,'previousHash'=block$block$previousHash)\n  #  list('message'='New block forged', c('index'= block$block$index, 'transactions'= block$block$transactions, 'proof'=block$block$proof,'previousHash'=block$block$previousHash))\n}\n#* @serializer custom_json\n#* @post /nodes/register\nfunction (req)\n{\n  #  req_json <- '{\"sender\": \"my address\", \"recipient\": \"someone else address\", \"amount\": 5}'\n  values <- jsonlite::fromJSON(req$postBody)\n  nodes <-  values$nodes\n  if (is.null(nodes))\n  {\n    return(\"Error: the list of nodes is not valid\")\n  }\n  for (i in 1:length(nodes))\n  {\n    blockchain$registerNode(nodes[i])\n  }\n  TRUE\n}\n#* @serializer custom_json\n#* @get /nodes/resolve\nfunction (req)\n{\n  replaced = blockchain$handleConflicts()\n  if (replaced)\n  {\n    list('message'='Replaced', 'chain'=blockchain$chain)\n  } else  {\n    list('message'='Authoritative block chain - not replaceable ', 'chain'=blockchain$chain)\n  }\n}\n#* Log some information about the incoming request\n#* @filter logger\nfunction(req){\n  cat(as.character(Sys.time()), \"-\", \n      req$REQUEST_METHOD, req$PATH_INFO, \"-\", \n      req$HTTP_USER_AGENT, \"@\", req$REMOTE_ADDR, \"\\n\")\n  plumber::forward()\n}\n#* @get /chain/show\n#* @html\nfunction(req)\n  {\n  render.html <- \"\"\n  \n  paste0(render.html, '<br>')\n  render.html <- paste0(render.html, 'Current transactions:<br>')\n  for (i in 1:length(blockchain$currentTransactions))\n  {\n    render.html <- paste0(render.html, 'Transaction' , i ,'<br>')\n    render.html <- paste0(render.html, 'sender:', blockchain$currentTransactions[i]$transaction$sender)\n    render.html <- paste0(render.html, '<br>')\n    render.html <- paste0(render.html, 'recipient:', blockchain$currentTransactions[i]$transaction$recipient)\n    render.html <- paste0(render.html, '<br>')\n    render.html <- paste0(render.html, 'amount:', blockchain$currentTransactions[i]$transaction$amount)\n    render.html <- paste0(render.html, '<br>')\n  }\n  render.html <- paste0(render.html, '<br>')\n  render.html <- paste0(render.html, 'Current transactions:')\n  render.html <- paste0(render.html, '<div>')\n  for (i in 1:blockchain$lastBlock()$block$index)\n  {\n    render.html <- paste0(render.html, '<br>')\n    render.html <- paste0(render.html, '<b>Block nr:</b>', blockchain$chain[i]$block$index)\n    render.html <- paste0(render.html, '<br>')\n    render.html <- paste0(render.html, '<b>Transactions</b>')\n    render.html <- paste0(render.html, '<br>')\n    render.html <- paste0(render.html, blockchain$chain[i]$block$transactions)\n    render.html <- paste0(render.html, '<br') \n    render.html=\"\" <-=\"\" paste0(render.html,=\"\" '<b=\"\">Proof')\n    render.html <- paste0(render.html, '<br>')\n    render.html <- paste0(render.html,blockchain$chain[i]$block$proof)\n    render.html <- paste0(render.html, '<br>')\n  }\n  render.html <- paste0(render.html, '</br')><'/div>')\n  render.html\n}\n\n\n",
    "created" : 1520692152023.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "928549978",
    "id" : "D9E402DA",
    "lastKnownWriteTime" : 1520692532,
    "last_content_update" : 1520692532126,
    "path" : "/media/hi/C2ACA28AACA278951/Windows/work/R/blockchain/class.R",
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}